package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"
	"fmt"
	"grocerysmart/auth-service/database"
	"grocerysmart/auth-service/graph/model"
	"os"
	"time"

	jwt "github.com/dgrijalva/jwt-go"
	"github.com/lib/pq"
	"golang.org/x/crypto/bcrypt"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.NewUser) (*model.AuthPayload, error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("security error: failed to hash password")
	}

	tx, err := database.DB.Begin()
	if err != nil {
		return nil, fmt.Errorf("internal server error")
	}
	defer tx.Rollback()

	var userID int
	// Note: model.NewUser.ZipCode is generated from schema.graphql
	queryUser := `INSERT INTO users (email, password_hash, zip_code) VALUES ($1, $2, $3) RETURNING id`
	err = tx.QueryRow(queryUser, input.Email, string(hashedPassword), input.ZipCode).Scan(&userID)
	if err != nil {
		return nil, fmt.Errorf("user with email %s already exists", input.Email)
	}

	queryPrefs := `INSERT INTO user_preferences (user_id, zip_code) VALUES ($1, $2)`
	_, err = tx.Exec(queryPrefs, userID, input.ZipCode)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize user profile")
	}

	if err := tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to finalize user creation")
	}

	token, err := generateToken(userID, input.Email)
	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:    fmt.Sprintf("%d", userID),
			Email: input.Email,
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginUser) (*model.AuthPayload, error) {
	var userID int
	var storedHash string
	err := database.DB.QueryRow(`SELECT id, password_hash FROM users WHERE email = $1`, input.Email).Scan(&userID, &storedHash)
	if err != nil {
		return nil, fmt.Errorf("invalid credentials")
	}

	if err := bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(input.Password)); err != nil {
		return nil, fmt.Errorf("invalid credentials")
	}

	token, err := generateToken(userID, input.Email)
	return &model.AuthPayload{
		Token: token,
		User:  &model.User{ID: fmt.Sprintf("%d", userID), Email: input.Email},
	}, nil
}

// UpdatePreferences is the resolver for the updatePreferences field.
func (r *mutationResolver) UpdatePreferences(ctx context.Context, userID string, zipCode *string, preferredStores []string) (bool, error) {
	_, err := database.DB.Exec(`
		INSERT INTO user_preferences (user_id, zip_code, preferred_store_ids)
		VALUES ($1, $2, $3)
		ON CONFLICT (user_id) DO UPDATE 
		SET zip_code = EXCLUDED.zip_code, 
			preferred_store_ids = EXCLUDED.preferred_store_ids`,
		userID, zipCode, pq.Array(preferredStores))
	return err == nil, err
}

// SavePlan is the resolver for the savePlan field.
func (r *mutationResolver) SavePlan(ctx context.Context, age int, gender string, activityLevel string, weeklyCalories int, dailyProtein int) (*model.Plan, error) {
	var newID int
	err := database.DB.QueryRow(
		`INSERT INTO plans (age, gender, activity_level, weekly_calories, daily_protein) 
         VALUES ($1, $2, $3, $4, $5) RETURNING id`,
		age, gender, activityLevel, weeklyCalories, dailyProtein,
	).Scan(&newID)

	if err != nil {
		return nil, err
	}
	return &model.Plan{
		ID:             fmt.Sprintf("%d", newID),
		Age:            age,
		Gender:         gender,
		ActivityLevel:  activityLevel,
		WeeklyCalories: weeklyCalories,
		DailyProtein:   dailyProtein,
	}, nil
}

// SendWeeklyPlan is the resolver for the sendWeeklyPlan field.
func (r *mutationResolver) SendWeeklyPlan(ctx context.Context, userID string) (bool, error) {
	panic(fmt.Errorf("not implemented: SendWeeklyPlan - sendWeeklyPlan"))
}

// SuggestedRecipes is the resolver for the suggestedRecipes field.
func (r *queryResolver) SuggestedRecipes(ctx context.Context) ([]*model.Recipe, error) {
	// 1. Get user ID from the Context (populated by Auth Middleware)
	userID, ok := ctx.Value("user_id").(string)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// 2. Fetch User Prefs to pass to the Plan Engine
	var storeIDs []string
	err := database.DB.QueryRow(`SELECT preferred_store_ids FROM user_preferences WHERE user_id = $1`, userID).Scan(pq.Array(&storeIDs))
	if err != nil {
		return []*model.Recipe{}, nil // Return empty if no prefs found
	}

	// 3. Delegate to the Plan Engine
	return r.fetchOptimizedPlanFromPython(ctx, userID, storeIDs)
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context, search *string) ([]*model.Item, error) {
    searchTerm := "%"
    if search != nil {
        searchTerm = "%" + *search + "%"
    }

    // Ensure the SELECT order matches the SCAN order exactly
    rows, err := database.DB.Query(`SELECT id, sku, name, brand, price_current, price_regular FROM items WHERE name ILIKE $1 LIMIT 20`, searchTerm)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var items []*model.Item
    for rows.Next() {
        var i model.Item
        // Scan into the fields we just added to the schema
        if err := rows.Scan(&i.ID, &i.Sku, &i.Name, &i.Brand, &i.PriceCurrent, &i.PriceRegular); err == nil {
            items = append(items, &i)
        }
    }
    return items, nil
}

// SalesReceipt is the resolver for the salesReceipt field.
func (r *queryResolver) SalesReceipt(ctx context.Context, limit *int) ([]*model.Item, error) {
	return []*model.Item{}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
var jwtKey = []byte(os.Getenv("JWT_SECRET"))

func (r *queryResolver) fetchOptimizedPlanFromPython(ctx context.Context, userID string, storeIDs []string) ([]*model.Recipe, error) {
	// Architectural Placeholder: This would be an internal HTTP call to the Plan Engine
	// fmt.Printf("Calling Plan Engine for user %s with stores %v\n", userID, storeIDs)
	return []*model.Recipe{}, nil
}
func generateToken(userID int, email string) (string, error) {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user_id": userID,
		"email":   email,
		"exp":     time.Now().Add(time.Hour * 72).Unix(),
	})
	return token.SignedString(jwtKey)
}
